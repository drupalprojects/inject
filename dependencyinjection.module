<?php

/**
 * @file
 * Enables Symfony's Dependency Injection Component.
 *
 * This code is a direct backport from Drupal 8.
 */

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;

/**
 * Implements hook_init().
 */
function dependencyinjection_init() {
  // Activates the class loader.
  $loader = drupal_classloader();
  $loader->registerNamespace('Symfony\Component\DependencyInjection', __DIR__ . '/vendor/symfony/dependency-injection');

  $file = conf_path() . '/cache/container.php';
  if (file_exists($file)) {
    require_once $file;
  }

  if (class_exists('CachedContainer', FALSE)) {
    module_invoke_all('container', drupal_container(new CachedContainer()));
  }
  else {
    dependencyinjection_rebuild();
  }
}

/**
 * Tells drupal to dump the container on page exit.
 */
function dependencyinjection_needs_dumping() {
  global $conf;
  // By-pass the db_merge request.
  $conf['dependencyinjection_needs_dumping'] = TRUE;
}

/**
 * Re-build the dependency injection container.
 *
 * Note: do not call this on a hook_init().
 */
function dependencyinjection_rebuild() {
  // Configures the dependency injection container.
  drupal_container($container = new ContainerBuilder());
  module_invoke_all('container_config', $container);
  module_invoke_all('container', $container);
  dependencyinjection_needs_dumping();
}

/**
 * Implements hook_exit().
 */
function dependencyinjection_exit() {
  // If the container needs to be dumped.
  if (variable_get('dependencyinjection_needs_dumping', FALSE)) {
    $container = drupal_container();

    $dumper = new PhpDumper($container);
    file_put_contents(
      conf_path() . '/cache/container.php',
      $dumper->dump(array('class' => 'CachedContainer'))
    );
  }
}

/**
 * Retrieves the Drupal Container to standardize object construction.
 *
 * The container is built by the kernel and passed in to this function which
 * stores it statically. The container always contains the services from
 * \Drupal\Core\CoreBundle, the bundles of enabled modules and any other
 * bundles defined in $GLOBALS['conf']['container_bundles'].
 *
 * @see Drupal\Core\DrupalKernel
 *
 * @param Symfony\Component\DependencyInjection\ContainerInterface $new_container
 *   (optional) A new container instance to replace the current.
 *
 * @return Symfony\Component\DependencyInjection\ContainerInterface|bool
 *   The instance of the ContainerInterface used to set up and maintain
 *   object instances or FALSE if none exist yet.
 */
function drupal_container(ContainerInterface $new_container = NULL) {
  // We do not use drupal_static() here because we do not have a mechanism by
  // which to reinitialize the stored objects, so a drupal_static_reset() call
  // would leave Drupal in a nonfunctional state.
  static $container;
  if (isset($new_container)) {
    $container = $new_container;
  }
  return $container;
}
