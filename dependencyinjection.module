<?php

/**
 * @file
 * Enables Symfony's Dependency Injection Component.
 */

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;

/**
 * Implements hook_boot().
 */
function dependencyinjection_boot() {
  // Activates the class loader.
  $loader = drupal_classloader();
  $loader->registerNamespace('Symfony\Component\DependencyInjection', __DIR__ . '/vendor/symfony/dependency-injection');

  if (variable_get('dependencyinjection_dump', TRUE)) {
    // This is the last module (weight=1000) to be booted, load the cached
    // version of the container in order to allow hook_init() to alleviate
    // dependency injection.
    require_once dependencyinjection_file();
    drupal_container(new CachedContainer());
  }
  else {
    // The cached version of the container does not exist, trigger a rebuild.
    // Note: this operation is expensive and configuration should be dumped in
    // production sites.
    dependencyinjection_rebuild();
  }
}

/**
 * Implements hook_form_system_performance_settings_alter().
 */
function dependencyinjection_form_system_performance_settings_alter(&$form, $form_state) {
  $form['dependencyinjection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Dependency Injection Container'),
    '#description' => t('Dumping the configuration can enhance performances, by compiling, dumping and caching the resulting file to disk.')
  );
  $form['dependencyinjection']['dependencyinjection_dump'] = array(
    '#type' => 'checkbox',
    '#title' => t('Dump the configuration'),
    '#default_value' => variable_get('dependencyinjection_dump', TRUE),
    '#enabled' => file_exists(dependencyinjection_file()),
  );

  $form['#submit'][] = 'dependencyinjection_form_system_performance_settings_submit';
}

/**
 * Submits dependencyinjection_form_system_performance_settings_alter() form.
 */
function dependencyinjection_form_system_performance_settings_submit($form, &$form_state) {
  $form_dump = $form['dependencyinjection']['dependencyinjection_dump'];
  if ($form_dump['#default_value'] == 0 && $form_dump['#value'] == 1) {
    dependencyinjection_rebuild();
  }
}

/**
 * Tells drupal to dump the container on page exit.
 */
function dependencyinjection_needs_dumping() {
  global $conf;
  // By-pass the db_merge request.
  $conf['dependencyinjection_needs_dumping'] = variable_get('dependencyinjection_dump', FALSE);
}

/**
 * Re-build the dependency injection container.
 */
function dependencyinjection_rebuild() {
  // Configures the dependency injection container.
  drupal_container($container = new ContainerBuilder());
  module_invoke_all('container', $container);
  dependencyinjection_needs_dumping();
}

function dependencyinjection_folder() {
  return conf_path() . '/files/inject';
}

function dependencyinjection_file() {
  return conf_path() . '/files/inject/container.php';
}
/**
 * Implements hook_exit().
 */
function dependencyinjection_exit() {
  // If the container needs to be dumped.
  if (variable_get('dependencyinjection_needs_dumping', FALSE)) {
    $container = drupal_container();

    $dumper = new PhpDumper($container);
    file_put_contents(
      dependencyinjection_file(),
      $dumper->dump(array('class' => 'CachedContainer'))
    );
  }
}

/**
 * Implements hook_flush_caches().
 */
function dependencyinjection_flush_caches() {
  dependencyinjection_rebuild();
  return array();
}

/**
 * Retrieves the Drupal Container to standardize object construction.
 *
 * @param Symfony\Component\DependencyInjection\ContainerInterface $new_container
 *   (optional) A new container instance to replace the current.
 *
 * @return Symfony\Component\DependencyInjection\ContainerInterface|bool
 *   The instance of the ContainerInterface used to set up and maintain
 *   object instances or FALSE if none exist yet.
 */
function drupal_container(ContainerInterface $new_container = NULL) {
  // We do not use drupal_static() here because we do not have a mechanism by
  // which to reinitialize the stored objects, so a drupal_static_reset() call
  // would leave Drupal in a nonfunctional state.
  static $container;
  if (isset($new_container)) {
    $container = $new_container;
  }
  return $container;
}
