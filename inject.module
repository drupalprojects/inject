<?php

/**
 * @file
 * Integrates Symfony's Dependency Injection Component.
 */

use Drupal\Component\PhpStorage\PhpStorageFactory;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;

/**
 * Implements hook_boot().
 */
function inject_boot() {
  inject_register();

  if (variable_get('inject_dump', TRUE)) {
    // This is the last module (weight=1000) to be booted, load the cached
    // version of the container in order to allow hook_init() to alleviate
    // dependency injection.
    $class = inject_class();
    $cache_file = $class . '.php';

    // First, try to load.
    if (!class_exists($class, FALSE)) {
      inject_storage()->load($cache_file);
    }
    // If the load succeeded or the class already existed, use it.
    if (class_exists($class, FALSE)) {
      drupal_container(new $class);
      return;
    }
  }

  // The cached version of the container does not exist, trigger a rebuild.
  // Note: this operation is expensive and configuration should be dumped in
  // production sites.
  inject_rebuild('boot');
}

/**
 * Gets the PHP code storage object to use for the compiled container.
 *
 * @return Drupal\Component\PhpStorage\PhpStorageInterface
 */
function inject_storage() {
  static $storage;
  if (!isset($storage)) {
    $storage = PhpStorageFactory::get('service_container');
  }
  return $storage;
}

/**
 * Returns the class name based on environment, debug and testing prefix.
 *
 * @return string
 *   The class name.
 */
function inject_class() {
  return variable_get('inject_class', 'ServiceContainer');
}

/**
 * Gets the container's base class.
 *
 * All names except Container must be fully qualified.
 *
 * @return string
 */
function inject_base_class() {
  return variable_get('inject_base_class', 'Container');
}

/**
 * Implements hook_init().
 */
function inject_init() {
  // If somewhere in the init process the container needs to be dumped, it
  // generally means the loading of the cached class failed or an operation
  // asking for a full rebuild has been submitted.
  if (variable_get('inject_needs_dumping', FALSE)) {
    // Re-use the container in a non-bootstrap context.
    inject_rebuild('init');
  }
}

/**
 * Implements hook_form_system_performance_settings_alter().
 */
function inject_form_system_performance_settings_alter(&$form, $form_state) {
  drupal_add_js(drupal_get_path('module', 'inject') . '/inject.js');
  // Add JS to enable / disable the 'Compile configuration' checkbox.
  drupal_add_js('jQuery(function () { Drupal.enableCompileConfigurationCheckbox(); });', 'inline');

  $form['inject'] = array(
    '#type' => 'fieldset',
    '#title' => t('Dependency Injection Container'),
    '#description' => t('Dumping the configuration can enhance performances, by compiling, dumping and caching the resulting file to disk.')
  );

  $writeable = inject_storage()->writeable();
  $form['inject']['inject_dump'] = array(
    '#type' => 'checkbox',
    '#title' => t('Dump configuration to disk.'),
    '#default_value' => variable_get('inject_dump', TRUE) && $writeable,
    '#disabled' => !$writeable,
  );

  $dump_config = $form['inject']['inject_dump']['#default_value'];
  $form['inject']['inject_compile'] = array(
    '#type' => 'checkbox',
    '#title' => t('Compile configuration.'),
    '#default_value' => variable_get('inject_compile', FALSE) && $dump_config,
    '#disabled' => !$dump_config
  );

  $form['#submit'][] = 'inject_form_system_performance_settings_submit';
}

/**
 * Submits inject_form_system_performance_settings_alter() form.
 */
function inject_form_system_performance_settings_submit($form, &$form_state) {
  $form_dump = $form['inject']['inject_dump'];
  if ($form_dump['#default_value'] == 0 && $form_dump['#value'] == 1) {
    $GLOBALS['conf']['inject_needs_dumping'] = TRUE;
  }
}

/**
 * Implements hook_hook_info().
 */
function inject_hook_info() {
  $hooks['inject_boot'] = array(
    'group' => 'inject',
  );
  $hooks['inject_init'] = array(
    'group' => 'inject',
  );

  return $hooks;
}

/**
 * Re-build the dependency injection container.
 *
 * @param string $phase
 *   (Optional) The phase container is rebuilt.
 */
function inject_rebuild($phase = 'runtime') {
  if ($phase == 'boot') {
    // In the bootstrap phase, either a cached container is loaded from dumped
    // file, either a new container is created; In which case inject_rebuild is
    // called. In order to be able to dump a container the class has to be a
    // ContainerBuilder.
    module_invoke_all('inject_boot', drupal_container(new ContainerBuilder()));
  }
  else if ($phase == 'init') {
    // In the init phase, the container must be a ContainerBuilder. Operations
    // configuring this container is expected. This must not be called if a
    // container has not be previously set.
    module_invoke_all('inject_init', drupal_container());
  }
  else if ($phase == 'runtime') {
    // Re-building a container at runtime is an edge case but is useful when the
    // configuration has changed and the compiler need to be re-configured. This
    // will trigger a full rebuild as well as a full re-configuration.
    module_invoke_all('inject_boot', drupal_container(new ContainerBuilder()));
    module_invoke_all('inject_init', drupal_container());
  }

  // By-pass the db_merge request.
  $GLOBALS['conf']['inject_needs_dumping'] = variable_get('inject_dump', TRUE);
}

/**
 * Implements hook_exit().
 */
function inject_exit() {
  // If the container needs to be dumped.
  if (variable_get('inject_needs_dumping', FALSE)) {
    $container = drupal_container();

    if (variable_get('inject_compile', FALSE)) {
      // If Compile configuration is checked, compiles the container.
      $container->compile();
    }

    if (!inject_storage()->writeable()) {
      watchdog('inject', 'Container cannot be written to disk');
      return;
    }

    // Cache the container.
    $class = inject_class();
    $dumper = new PhpDumper($container);
    $content = $dumper->dump(array('class' => $class, 'base_class' => inject_base_class()));
    inject_storage()->save($class . '.php', $content);
  }
}

/**
 * Implements hook_flush_caches().
 */
function inject_flush_caches() {
  // In some context such as module activation, the boot method is not called so
  // the component is never registered with the class loader. This cause
  // troubles as we need the class definition when re-building the container.
  inject_register();
  // Re-build can now safely be called.
  inject_rebuild();
  return array();
}

/**
 * Registers the Dependency Injection name-space with the class loader.
 */
function inject_register() {
  // Activates the class loader.
  $loader = drupal_classloader();
  $loader->registerNamespace('Drupal\Component\PhpStorage', __DIR__ . '/lib');
  $loader->registerNamespace('Symfony\Component\DependencyInjection', __DIR__ . '/vendor/symfony/dependency-injection');
}

/**
 * Retrieves the Drupal Container to standardize object construction.
 *
 * @param Symfony\Component\DependencyInjection\ContainerInterface $new_container
 *   (optional) A new container instance to replace the current.
 *
 * @return Symfony\Component\DependencyInjection\ContainerInterface|bool
 *   The instance of the ContainerInterface used to set up and maintain
 *   object instances or FALSE if none exist yet.
 */
function drupal_container(ContainerInterface $new_container = NULL) {
  // We do not use drupal_static() here because we do not have a mechanism by
  // which to reinitialize the stored objects, so a drupal_static_reset() call
  // would leave Drupal in a nonfunctional state.
  static $container;
  if (isset($new_container)) {
    $container = $new_container;
  }
  return $container;
}
