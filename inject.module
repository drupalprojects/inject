<?php

/**
 * @file
 * Enables Symfony's Dependency Injection Component.
 */

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;

/**
 * Implements hook_boot().
 */
function inject_boot() {
  inject_register();

  if (variable_get('inject_dump', TRUE)) {
    // This is the last module (weight=1000) to be booted, load the cached
    // version of the container in order to allow hook_init() to alleviate
    // dependency injection.
    require_once inject_file();
    drupal_container(new CachedContainer());
  }
  else {
    // The cached version of the container does not exist, trigger a rebuild.
    // Note: this operation is expensive and configuration should be dumped in
    // production sites.
    inject_rebuild('boot', new ContainerBuilder());
  }
}

/**
 * Implements hook_init().
 */
function inject_init() {
  if (!variable_get('inject_dump', TRUE)) {
    // Re-build a second time the container in a non-bootstrap context.
    inject_rebuild('init');
  }
}

/**
 * Implements hook_form_system_performance_settings_alter().
 */
function inject_form_system_performance_settings_alter(&$form, $form_state) {
  drupal_add_js(drupal_get_path('module', 'inject') . '/inject.js');
  // Add JS to enable / disable the 'Compile configuration' checkbox.
  drupal_add_js('jQuery(function () { Drupal.enableCompileConfigurationCheckbox(); });', 'inline');

  $form['inject'] = array(
    '#type' => 'fieldset',
    '#title' => t('Dependency Injection Container'),
    '#description' => t('Dumping the configuration can enhance performances, by compiling, dumping and caching the resulting file to disk.')
  );

  $file_exists = file_exists(inject_folder());
  $form['inject']['inject_dump'] = array(
    '#type' => 'checkbox',
    '#title' => t('Dump configuration to disk.'),
    '#default_value' => variable_get('inject_dump', TRUE) && $file_exists,
    '#disabled' => !$file_exists,
  );

  $dump_config = $form['inject']['inject_dump']['#default_value'];
  $form['inject']['inject_compile'] = array(
    '#type' => 'checkbox',
    '#title' => t('Compile configuration.'),
    '#default_value' => variable_get('inject_compile', FALSE) && $dump_config,
    '#disabled' => !$dump_config
  );

  $form['#submit'][] = 'inject_form_system_performance_settings_submit';
}

/**
 * Submits inject_form_system_performance_settings_alter() form.
 */
function inject_form_system_performance_settings_submit($form, &$form_state) {
  $form_dump = $form['inject']['inject_dump'];
  if ($form_dump['#default_value'] == 0 && $form_dump['#value'] == 1) {
    $GLOBALS['conf']['inject_needs_dumping'] = TRUE;
  }
}

/**
 * Re-build the dependency injection container.
 *
 * @param string $phase
 *   (Optional) The phase container is rebuilt.
 * @param ContainerInterface $container
 *   (Optional) The container to re-build.
 */
function inject_rebuild($phase = 'runtime', ContainerInterface $container = NULL) {
  if ($phase == 'boot') {
    // In the bootstrap phase, either a cached container is loaded from dumped
    // file, either a new container is created; In which case inject_rebuild is
    // called. In order to be able to dump a container the class has to be a
    // ContainerBuilder.
    $container = empty($container) ? new ContainerBuilder() : $container;
    module_invoke_all('inject_boot', $container);
  }
  else if ($phase == 'init') {
    // In the init phase, the container must be a ContainerBuilder. Operations
    // configuring this container is expected. This must not be called if a
    // container has not be previously set.
    $container = empty($container) ? drupal_container() : $container;
    module_invoke_all('inject_init', $container);
  }
  else if ($phase == 'runtime') {
    // Re-building a container at runtime is an edge case but is useful when the
    // configuration has changed and the compiler need to be re-dumped. This
    // will trigger a full rebuild as well as a full re-configuration.
    $container = empty($container) ? new ContainerBuilder() : $container;
    module_invoke_all('inject_boot', $container);
    module_invoke_all('inject_init', $container);
  }

  // By-pass the db_merge request.
  $GLOBALS['conf']['inject_needs_dumping'] = variable_get('inject_dump', TRUE);
  // Re-set the container.
  drupal_container($container);
}

/**
 * Returns the inject folder path.
 */
function inject_folder() {
  return variable_get('inject_folder', conf_path() . '/files/inject');
}

/**
 * Returns the inject file uri.
 */
function inject_file() {
  return inject_folder() . '/' . variable_get('inject_file', 'container.php');
}
/**
 * Implements hook_exit().
 */
function inject_exit() {
  // If the container needs to be dumped.
  if (variable_get('inject_needs_dumping', FALSE)) {
    $container = drupal_container();

    if (variable_get('inject_compile', FALSE)) {
      // If Compile configuration is checked, compiles the container.
      $container->compile();
    }

    $dumper = new PhpDumper($container);
    file_put_contents(
      inject_file(),
      $dumper->dump(array('class' => 'CachedContainer'))
    );
  }
}

/**
 * Implements hook_flush_caches().
 */
function inject_flush_caches() {
  // In some context such as module activation, the boot method is not called so
  // the component is never registered with the class-loader. This cause
  // troubles as we need the class definition when re-building the container.
  inject_register();
  // Re-build can now safely be called.
  inject_rebuild();
  return array();
}

/**
 * Registers the Dependency Injection name-space with the class-loader.
 */
function inject_register() {
  // Activates the class loader.
  drupal_classloader()->registerNamespace('Symfony\Component\DependencyInjection', __DIR__ . '/vendor/symfony/dependency-injection');
}

/**
 * Retrieves the Drupal Container to standardize object construction.
 *
 * @param Symfony\Component\DependencyInjection\ContainerInterface $new_container
 *   (optional) A new container instance to replace the current.
 *
 * @return Symfony\Component\DependencyInjection\ContainerInterface|bool
 *   The instance of the ContainerInterface used to set up and maintain
 *   object instances or FALSE if none exist yet.
 */
function drupal_container(ContainerInterface $new_container = NULL) {
  // We do not use drupal_static() here because we do not have a mechanism by
  // which to reinitialize the stored objects, so a drupal_static_reset() call
  // would leave Drupal in a nonfunctional state.
  static $container;
  if (isset($new_container)) {
    $container = $new_container;
  }
  return $container;
}
